-*- org -*-

* Bytecode format

For the bytecode format, we basically need to reverse engineer what
was done in: 
 - bytecomp/emitcode.ml (cmo)
 - bytecomp/bytelibrarian.ml (cma)
 - bytecomp/bytelink.ml (final executable)

See also bytecomp/cmo_format.mli

* FFI

How to call C code? We can't interpret C code ...
The C code needs to be linked with zamcov-run so we just
need to find the address of this code and jump there.
How to jump there? We can abuse the 'external' mechanism of 
ocaml itself for that :)

But then this C code assumes the ocaml C value runtime
representation, not the special one we use in value.ml.
So we need to convert back and forth, hence the Ffi.wrap
to go from Value.value to Obj.t (Ffi.obj_of_value), and then get the
result back in a Value.value (Utils.value_of_obj)

** What is clibs for?
Just to create all the external declarations from the ocaml
standard libraries and otherlibs and the redirect and wrappers
so that they can work on Value.

** What is mllibs for?

Because some functions in the stdlib do weird things around values
(compare, callback, obj) and we need to imitate that because we have
our own value representation.

* interpreter

** value
Value.value vs Obj.t

** GC?
How it works? We just use the ocaml GC itself that will work on Value.value.
Just like a lisp interpreter written in LISP just use implicitly
the Lisp GC.

There should never be calls to the C functions from the GC??

* Link to source code

How the original zamcov links bytecode to source code?
Apparently they assume a .cmo.cover and so a patched version of
the compiler. I don't want that, I think with compiler-libs we have
enough info to find back the functions involved!

* Related

O'Browser, interpreter bytecode, but written in Javascript.
Cadmium, interpreter bytecode, but written in Java.
